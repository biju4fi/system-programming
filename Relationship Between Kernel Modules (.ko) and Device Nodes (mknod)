# Relationship Between Kernel Modules (.ko) and Device Nodes (mknod)

This document explains how a **Linux kernel module** (`.ko`) and a **device node** created with `mknod` are related, and how user space interacts with them.

---

## Overview

- **Kernel Module (`.ko`)**: The driver code that runs inside the Linux kernel.
- **Device Node (`/dev/...`)**: A special file that acts as a handle for user-space programs to talk to the driver.
- **Major Number**: The link between the device node and the driver.

---

## Step-by-Step Relationship

### 1. `.ko` side
When a kernel module is loaded (e.g., `sudo insmod mychardev.ko`):

1. The kernel runs the module's `module_init()` function.
2. Inside this, `register_chrdev()` is called to request a **major number**.
3. The kernel returns a major number (e.g., `240`) and stores it in the device table.

Example in code:
```c
major = register_chrdev(0, "mychardev", &fops);
```
- `0` → ask for a dynamic major number.
- `"mychardev"` → driver name.
- `&fops` → pointer to file operation functions (`.open`, `.read`, `.write`, etc.).

Now the kernel knows:
```
Major 240 → mychardev driver (in .ko)
```

---

### 2. `mknod` side
Manually create a device node that points to this driver:
```bash
sudo mknod /dev/mychardev c 240 0
sudo chmod 666 /dev/mychardev
```
- `c` → character device.
- `240` → **must match** the major number assigned to your driver.
- `0` → minor number (for the first device instance).

This creates a special file:
```
crw-rw-rw- 1 root root 240, 0 /dev/mychardev
```

---

### 3. The bridge
When a user-space program calls:
```c
fd = open("/dev/mychardev", O_RDWR);
write(fd, "hello", 5);
```
**The kernel:**
1. Looks up the device node’s metadata.
2. Finds `major=240` → maps to the mychardev driver.
3. Calls the driver’s `.open()` or `.write()` in the kernel.

Without `mknod` (or automatic udev creation), there’s no `/dev/...` entry, so user programs can’t access the driver.

---

## Visual Diagram

```
           (A) Kernel module path                              (B) Device node path
           -----------------------                              -------------------

 [insmod mychardev.ko]                                   [sudo mknod /dev/mychardev c <MAJOR> 0]
          |                                                           |
          v                                                           v
   module_init(): my_init()                                    Special file in /dev
          |                                                     (type=c, major=<MAJOR>, minor=0)
          |   register_chrdev(0, "mychardev", &fops)                     |
          |   └─> Kernel assigns MAJOR = 240                             |
          v                                                               v
  Kernel device table:                                       ls -l /dev/mychardev -> c 240,0
     Major 240  ─────────────────────► mychardev fops

                          ┌────────────────────────────────────────────────────────┐
                          │                SYSCALL FLOW (user space)               │
                          └────────────────────────────────────────────────────────┘

User program:
  fd = open("/dev/mychardev", O_RDWR);
  write(fd, "hello", 5);
  read(fd, buf, n);
        |
        v
open("/dev/mychardev")  --> kernel looks at device node metadata
        |                        (type=c, major=240, minor=0)
        v
Kernel routes to major 240  ───────────────────────────────► mychardev .open()
                                                             mychardev .write()
                                                             mychardev .read()
                                                             (handlers in the .ko)

Result:
- The device node is the user-space handle (the "phone number").
- The .ko is the driver code living in the kernel (the "phone").
- The MAJOR number links the two so syscalls reach your driver.
```

---

## Key Takeaways
- The `.ko` registers a **major number** with the kernel.
- `mknod` creates a `/dev/...` entry pointing to that major.
- The **major number** is the bridge between kernel-space driver code and user-space access.
